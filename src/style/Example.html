<!doctype html>
<html>
	<head>
		<meta charset="utf-8" />
		<title>Smooth day/night gradient</title>
		<style>
		  html,body { height:100%; margin:0; }
		  body {
			/* initial fallback background */
			background: linear-gradient(to top, #2D0D01, #000000);
			color: #fff;
			font-family: system-ui, sans-serif;
			/* optional small smoothing for browsers that repaint a bit choppy */
			transition: background 90ms linear;
		  }

		  .content { position:relative; z-index:1; padding:2rem; }
		</style>
	</head>
	<body>
	  <div class="content">
		<h1>Day / Night cycle</h1>
		<p>JS interpolates the gradient colors each frame for a smooth blend.</p>
	  </div>

		<script>
		(function(){
		  // Phases: offsets are normalized positions in the loop (0..1).
		  // You can change offsets to hold longer/shorter at sunrise/midday etc.
		  const phases = [
			{ offset: 0.00, colors: ['#2D0D01', '#000000'] }, // midnight
			{ offset: 0.18, colors: ['#ffcc66', '#87ceeb'] }, // sunrise
			{ offset: 0.45, colors: ['#87ceeb', '#66ccff'] }, // midday
			{ offset: 0.72, colors: ['#ff9966', '#330066'] }, // sunset
			{ offset: 1.00, colors: ['#2D0D01', '#000000'] }  // back to midnight (wrap)
		  ];

		  const duration = 60_000; // full loop in milliseconds (change to taste)
		  let start = performance.now();

		  // Utility: hex <-> rgb
		  function hexToRgb(hex) {
			hex = hex.replace('#','');
			if (hex.length === 3) hex = hex.split('').map(c => c + c).join('');
			const n = parseInt(hex, 16);
			return { r: (n >> 16) & 255, g: (n >> 8) & 255, b: n & 255 };
		  }
		  function rgbToHex({r,g,b}) {
			const h = v => v.toString(16).padStart(2,'0');
			return '#' + h(r) + h(g) + h(b);
		  }

		  // Linear interpolation
		  function lerp(a,b,t){ return a + (b - a) * t; }
		  function lerpColor(aHex, bHex, t){
			const A = hexToRgb(aHex), B = hexToRgb(bHex);
			return rgbToHex({
			  r: Math.round(lerp(A.r, B.r, t)),
			  g: Math.round(lerp(A.g, B.g, t)),
			  b: Math.round(lerp(A.b, B.b, t))
			});
		  }

		  // Smooth ease (ease in/out)
		  function ease(t){ return 0.5 * (1 - Math.cos(Math.PI * t)); }

		  // Main animation tick
		  function tick(now) {
			const elapsed = (now - start) % duration;
			const p = elapsed / duration; // normalized progress 0..1

			// find segment [phases[i], phases[i+1]] that contains p
			let i = 0;
			for (let k = 0; k < phases.length - 1; k++) {
			  if (p >= phases[k].offset && p < phases[k+1].offset) { i = k; break; }
			  if (k === phases.length - 2 && p >= phases[k+1].offset) i = k; // fallback
			}

			const A = phases[i], B = phases[i+1];
			const segLen = (B.offset - A.offset) || 1e-6;
			let t = (p - A.offset) / segLen;
			t = Math.min(Math.max(t, 0), 1);
			t = ease(t);

			// interpolate both color stops
			const c0 = lerpColor(A.colors[0], B.colors[0], t);
			const c1 = lerpColor(A.colors[1], B.colors[1], t);

			// set background (this runs every frame)
			document.body.style.background = `linear-gradient(to top, ${c0}, ${c1})`;

			requestAnimationFrame(tick);
		  }

		  requestAnimationFrame(tick);
		})();
		</script>
	</body>
</html>